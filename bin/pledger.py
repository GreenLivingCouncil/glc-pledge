import sqlite3
import datetime
import logging
import cgi
import json
import re
import os
from collections import namedtuple

# Global Constants/Variables
DEBUG          = True
ALLOW_MULTIPLE = True
LOG_PATH       = "pledger.log"
DB_PATH        = "pledges.db"
conn           = None

def __init__():
    """
    Init procedure called on import.
    """
    global conn

    if DEBUG:
        import cgitb
        cgitb.enable()

    log_level = logging.DEBUG if DEBUG else logging.INFO
    logging.basicConfig(filename=LOG_PATH, level=log_level)
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = namedtuple_factory

class WebAuthToken(object):
    sunet_id = os.environ['WEBAUTH_USER']
    email = os.environ['WEBAUTH_LDAP_MAIL']
    name =  os.environ['WEBAUTH_LDAP_DISPLAYNAME']

def namedtuple_factory(cursor, row):
    """
    Usage:
    con.row_factory = namedtuple_factory
    """
    fields = [col[0] for col in cursor.description]
    Row = namedtuple("Row", fields)
    return Row(*row)

def decamel(name):
    s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()

def json_get_view(view_func):
    def decorated():
        form = cgi.FieldStorage()
        params = dict( (decamel(key), form.getfirst(key)) for key in form )
        response = view_func(**params)

        print "Content-Type: application/json"
        print
        print json.dumps(response, sort_keys=True, indent=4, separators=(',', ': '))
    decorated()


def json_post_view(view_func):
    def decorated():
        form = cgi.FieldStorage()
        post_data = json.loads(form.value)
        response = view_func(post_data)

        print "Content-Type: application/json"
        print
        print json.dumps(response, sort_keys=True, indent=4, separators=(',', ': '))
    decorated()

def get_referral_counts(referrer):
    """
    Given the SUNet ID of the referrer, return the number of referrals accumulated.
    """
    t = (referrer,)
    return conn.execute("SELECT Count(*) as count FROM pledges WHERE referrer=?", t).fetchone()[0]

def get_pledge_counts(event_id):
    """
    Given the event ID, return a dict mapping team ID to the number of pledges counted 
    for each team.
    """
    t = (event_id,)
    cur = conn.execute("SELECT teamId, Count(*) AS count FROM pledges WHERE eventId=? GROUP BY teamId", t)
    return dict(cur.fetchall())

def make_pledge_dict(entry):
    """
    Given a single SQL namedtuple from the pledge table,
    return a dict with the display name, team ID, hours elapsed, and comments.
    """
    pledge_time = datetime.datetime.strptime(entry.dateString, '%Y-%m-%d %H:%M:%S.%f')

    return {
        "name": "Anonymous" if entry.private else entry.name,
        "teamId": entry.teamId,
        "isoDateString": pledge_time.isoformat(),
        "comments": entry.comments
        }

def get_pledges(event_id, max_pledges):
    """
    Return at most max_pledges pledges from event with event_id.
    Each pledge is in the format generated by make_pledge_dict().
    """
    cur = conn.execute("SELECT name, teamId, dateString, comments, private FROM pledges "
                       "WHERE eventId=:eventId ORDER BY dateString DESC LIMIT :limit",
                       {"eventId" : event_id, "limit" : max_pledges})
    entries = cur.fetchall()
    return [make_pledge_dict(entry) for entry in entries]

def has_pledged(sunet_id, event_id):
    """
    Returns True iff student is pledging for the first time in the event.
    """
    if ALLOW_MULTIPLE:
        return False
    t = (sunet_id, event_id)
    cur = conn.execute("SELECT EXISTS(SELECT 1 FROM pledges WHERE sunetId=? AND eventId=?) as pledged", t)
    return bool(cur.fetchone()[0])

PLEDGE_FIELDS = ["name", "sunetId", "email", "teamId", "eventId", "comments", "referrer", "private"]
def submit_pledge(pledge):
    """
    Add pledge to database.

    Pledge expected to have the following keys:
    name - pledger name
    sunetId - pledger SUNet ID
    email - pledger email address
    teamId - team ID
    eventId - event ID
    comments - comment string
    referrer - referrer SUNet ID
    private - anonymous flag
    """
    logging.debug(pledge)
    if any((field not in pledge) for field in PLEDGE_FIELDS):
        return False

    pledge['dateString'] = str(datetime.datetime.utcnow())

    try:
        with conn:
            conn.execute("INSERT INTO pledges (name, sunetId, email, teamId, eventId, dateString, comments, referrer, private) "
                         "VALUES (:name, :sunetId, :email, :teamId, :eventId, :dateString, :comments, :referrer, :private)", pledge)
        return True
    except sqlite3.Error as e:
        logging.error("sqlite3: " + str(e))
        return False

def draw_random_pledge(event_id):
    """
    Choose random pledge from the given event and return it.
    """
    event_id = str(event_id)
    cur = conn.execute("SELECT * FROM pledges WHERE eventId=? ORDER BY RANDOM() LIMIT 1", event_id)
    return cur.fetchone()

__init__()

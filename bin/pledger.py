import sqlite3
import datetime
import logging
import cgi
import json
import re
import os
from collections import namedtuple

# Global Constants/Variables
DEBUG          = False
ALLOW_MULTIPLE = False
ADMINS         = ["sashab", "ibarnard", "sckoo"]
LOG_PATH       = "pledger.log"
DB_PATH        = "pledges.db"
SCHEMA_PATH    = "sql/setup.sql"
conn           = None

class WebAuthToken(object):
    pass

def __init__():
    """
    Init procedure called on import.
    """
    global conn

    if DEBUG:
        import cgitb
        cgitb.enable()

    init_db = not os.path.exists(DB_PATH)
    log_level = logging.DEBUG if DEBUG else logging.INFO
    logging.basicConfig(filename=LOG_PATH, level=log_level)
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = namedtuple_factory

    if init_db:
        with open(SCHEMA_PATH) as f:
            conn.executescript(f.read())

    if 'WEBAUTH_USER' in os.environ:
        WebAuthToken.sunet_id = os.environ['WEBAUTH_USER']
        WebAuthToken.email = os.environ['WEBAUTH_LDAP_MAIL']
        WebAuthToken.name =  os.environ['WEBAUTH_LDAP_DISPLAYNAME']

def namedtuple_factory(cursor, row):
    """
    Usage:
    con.row_factory = namedtuple_factory
    """
    fields = [col[0] for col in cursor.description]
    Row = namedtuple("Row", fields)
    return Row(*row)

def decamel(name):
    s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()

def json_get_view(view_func):
    def decorated():
        form = cgi.FieldStorage()
        params = dict( (decamel(key), form.getfirst(key)) for key in form )
        response = view_func(**params)

        print "Content-Type: application/json"
        print
        print json.dumps(response, sort_keys=True, indent=4, separators=(',', ': '))
    decorated()


def json_post_view(view_func):
    def decorated():
        form = cgi.FieldStorage()
        post_data = json.loads(form.value)
        response = view_func(post_data)

        print "Content-Type: application/json"
        print
        print json.dumps(response, sort_keys=True, indent=4, separators=(',', ': '))
    decorated()

def get_referral_counts(referrer):
    """
    Given the SUNet ID of the referrer, return the number of referrals accumulated.
    """
    t = (referrer,)
    cur = conn.execute("SELECT Count(*) as count FROM pledges WHERE referrer=?", t)
    return cur.fetchone().count

def get_pledge_counts(event_id):
    """
    Given the event ID, return a dict mapping team ID to the number of pledges counted 
    for each team.
    """
    t = (event_id,)
    cur = conn.execute("SELECT teamId, Count(*) AS count FROM pledges WHERE eventId=? GROUP BY teamId", t)
    return dict(cur.fetchall())

def get_pledges(event_id, max_pledges=-1):
    """
    Return at most max_pledges pledges from event with event_id.
    Each pledge is in the format generated by make_pledge_dict().
    """
    cur = conn.execute("SELECT * FROM pledges "
                       "WHERE eventId=:eventId ORDER BY dateString DESC LIMIT :limit",
                       {"eventId" : event_id, "limit" : max_pledges})
    return cur.fetchall()

def has_pledged(sunet_id, event_id):
    """
    Returns True iff student is pledging for the first time in the event.
    """
    if ALLOW_MULTIPLE:
        return False
    t = (sunet_id, event_id)
    cur = conn.execute("SELECT EXISTS(SELECT 1 FROM pledges WHERE sunetId=? AND eventId=?) as pledged", t)
    return bool(cur.fetchone().pledged)

PLEDGE_FIELDS = ["name", "sunetId", "email", "teamId", "eventId", "comments", "referrer", "private"]
def submit_pledge(pledge):
    """
    Add pledge to database.

    Pledge expected to have the following keys:
    name - pledger name
    sunetId - pledger SUNet ID
    email - pledger email address
    teamId - team ID
    eventId - event ID
    comments - comment string
    referrer - referrer SUNet ID
    private - anonymous flag
    """
    logging.debug(pledge)
    if any((field not in pledge) for field in PLEDGE_FIELDS):
        return False

    admin_mode = (WebAuthToken.sunet_id in ADMINS)

    if not admin_mode and has_pledged(WebAuthToken.sunet_id, pledge['eventId']):
        return False

    pledge['dateString'] = str(datetime.datetime.utcnow())
    if not admin_mode and pledge['sunetId'] != WebAuthToken.sunet_id:
        return False

    try:
        with conn:
            conn.execute("INSERT INTO pledges (name, sunetId, email, teamId, eventId, dateString, comments, referrer, private) "
                         "VALUES (:name, :sunetId, :email, :teamId, :eventId, :dateString, :comments, :referrer, :private)", pledge)
        return True
    except sqlite3.Error as e:
        logging.error("sqlite3: " + str(e))
        return False

def draw_random_pledges(event_id, num_pledges):
    """
    Choose random pledge from the given event and return it.
    """
    t = (str(event_id), str(num_pledges))
    cur = conn.execute("SELECT * FROM pledges WHERE eventId=? ORDER BY RANDOM() LIMIT ?", t)
    return cur.fetchall()


__init__()
